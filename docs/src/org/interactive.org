#+TITLE:     Interactive Development

* Introduction

  Immutant provides two methods for connecting to an application's runtime
  with a REPL: Swank (for emacs & possibly vim if you are feeling adventurous)
  and nREPL (for any nREPL client).

  Each REPL service runs on a unique port, allowing you to have REPLs into
  multiple applications within the same Immutant, or multiple REPLs within the
  same application.

  REPL services can be started at application deploy time, or dynamically from
  application code. REPLs started dynamically can be also be shutdown
  dynamically. REPLs started at deploy time and any dynamically started REPLs
  that are not shut down by the application will be shut down when the
  application is undeployed.

  See [[./initialization.html#initialization-configuration][initialization configuration]]
  for a list of configuration options (like =:swank-port= and =:nrepl-port=)
  and how to apply them.

** Binding To An Interface
   :PROPERTIES:
   :CUSTOM_ID: interactive-binding
   :END:

   AS7 is setup to use multiple network interfaces, and allows you to specify
   different interfaces for your server: /public/, /management/, and /unsecure/.
   By default, these interfaces are all the same - =127.0.0.1=. But you can
   specify different addresses for each named interface, aiding in the security
   setup of your management ports.

   By default, the repl services started by Immutant bind to the /management/
   interface.

* nREPL

  [[https://github.com/clojure/tools.nrepl][nREPL]] is a client/server protocol that provides a Clojure REPL
  across a network. It has several clients that support it.

** Starting nREPL

   You can start a nREPL service using one (or both) of two methods:
   specifying an =:nrepl-port= option in your configuration, or by
   calling [[./apidoc/immutant.repl.html#var-start-nrepl][immutant.repl/start-nrepl]] from application code.

*** Starting nREPL Via :nrepl-port

    To have Immutant start a nREPL service on your behalf, you can specify
    an open port for it to bind to using the =:nrepl-port= configuration
    option. When using this option, Immutant will automatically
    [[#interactive-binding][bind to the management interface]].

    Immutant will write the nREPL port to a file beneath your
    project's =target/= directory called =repl-port=, following
    Leiningen's convention. Many nREPL clients will use this file to
    establish a connection. Setting =:nrepl-port= to 0 will cause the
    OS to return an unused port, avoiding potential conflicts. You can
    set this in your =~/.lein/profiles.clj= file to start an nREPL
    service for each application you deploy:

    #+begin_src clojure
      {:user {:plugins [[lein-immutant "0.18.1"]]
              :immutant {:nrepl-port 0}}}
    #+end_src

*** Starting nREPL Programatically

    You can also start a nREPL service from your own code, which is useful
    if you need to start it in response to a runtime event or bind to an
    interface other than the [[#interactive-binding][management interface]]. To do so, simply
    call [[./apidoc/immutant.repl.html#var-start-nrepl][immutant.repl/start-nrepl]]. nREPL allows you to have multiple
    services in the same runtime, so you need to save the return value of
    =start-nrepl= if you want to shut down the nREPL service yourself:

    #+begin_src clojure
      ;; bind to the given port on the management interface, and
      ;; save the service handle for later
      (def nrepl (immutant.repl/start-nrepl 4242))
      
      ;; bind to the given port and interface
      (immutant.repl/start-nrepl "127.0.0.1" 4242)
    #+end_src

** Connecting to nREPL

*** Connecting via Emacs
   :PROPERTIES:
   :CUSTOM_ID: interactive-nrepl-emacs
   :END:

    To connect to nREPL from Emacs, first install [[https://github.com/kingtim/nrepl.el][nrepl.el]], then connect
    to your running nREPL via the =nrepl= function (=M-x nrepl RET=). 
    It will prompt you for the host and port.

*** Connecting via reply

    [[https://github.com/trptcolin/reply/][reply]] is an enhanced REPL for Clojure, and supports connecting to an
    nREPL service. Currently, the simplest way to install =reply= is to
    clone the git repository and follow the [[https://github.com/trptcolin/reply/#readme][intructions in its README]].

    Once you have =reply= installed, you can connect to your remote nREPL:

    #+begin_src sh
      # connect to an nREPL bound to port 4242 on localhost
      $ reply --skip-default-init --attach 4242 
            
      # connect to an nREPL bound to port 4242 on 10.0.0.10
      $ reply --skip-default-init --attach 10.0.0.10:4242 
    #+end_src

    Note that we are passing the =--skip-default-init= option above. =reply=
    attempts to load some libraries that won't exist in the application's
    runtime within Immutant, and also creates handy =quit= & =exit= functions
    that map to =System/exit=, which will shutdown the entire application server.
    Passing the =--skip-default-init= option prevents =reply= from attempting
    to load those missing libraries and prevents the definition of =quit= and
    =exit=.
    
*** Connecting via Counterclockwise

    [[http://code.google.com/p/counterclockwise/][Counterclockwise]] is an Eclipse plugin for Clojure development. You can
    use it to connect to your Immutant nREPL session via /Window/ -> 
    /Connect to REPL/. It will prompt you for an ip address and port to 
    connect to.

** Shutting Down nREPL

   Immutant will automatically shutdown any nREPL services for you when your
   application is undeployed, but if you need to do so before undeploy you
   can do so using the [[./apidoc/immutant.repl.html#var-stop-nrepl][immutant.repl/stop-nrepl]] function. You'll need to
   pass it the service handle returned by the =start-nrepl= call:

   #+begin_src clojure
     (clojure.repl/stop-nrepl nrepl)
   #+end_src

   Since you need the service handle to stop an nREPL service, you can only
   manually stop nREPL's you start yourself. If you start an nREPL service
   via the =:nrepl-port= configuration option, your only recourse is to
   allow Immutant to shut it down for you on undeploy.

* Swank

  Swank is the server protocol for [[http://www.common-lisp.net/project/slime/][SLIME (The Superior Lisp
  Interactive Mode for Emacs)]], and Clojure Swank & SLIME support are
  provided by [[https://github.com/technomancy/swank-clojure][swank-clojure]] & [[https://github.com/technomancy/clojure-mode][clojure-mode]], respectively. 

** Starting Swank

   You can start a Swank service using one (or both) of two methods:
   specifying a =:swank-port= option in your configuration, or by
   calling [[./apidoc/immutant.repl.html#var-start-swank][immutant.repl/start-swank]] from application code. No matter
   which method you use, there can only be one Swank service running
   for an application.

*** Starting Swank Via :swank-port

    To have Immutant start a Swank service on your behalf, you can specify
    an open port for it to bind to using the =:swank-port= configuration
    option. When using this option, Immutant will automatically
    [[#interactive-binding][bind to the management interface]].

*** Starting Swank Programatically

    You can also start a Swank service from your own code, which is useful
    if you need to start it in response to a runtime event or bind to an
    interface other than the [[#interactive-binding][management interface]]. To do so, simply
    call [[./apidoc/immutant.repl.html#var-start-swank][immutant.repl/start-swank]]:

    #+begin_src clojure
      ;; bind to the given port on the management interface
      (clojure.repl/start-swank 4242)
      
      ;; bind to the given port and interface
      (clojure.repl/start-swank "127.0.0.1" 4242)
    #+end_src

** Connecting to Swank

*** Connecting via Emacs

    Installing SLIME under emacs to work with Clojure can be a painful and
    confusing process if done manually. The easiest way to do it is to follow
    the [[https://github.com/technomancy/swank-clojure][clojure-jack-in instructions]] from =swank-clojure=, and "jack in" to
    any Leiningen project. This will trigger =clojure-mode= to download and
    install a version of SLIME that is compatible with =swank-clojure=.
    Once you have jacked in at least once, you can then connect to the Swank
    service within your Immutant application via the =slime-connect= emacs
    function (=M-x slime-connect RET=).

    Note that =swank-clojure= is now deprecated in favor of [[#interactive-nrepl-emacs][nrepl.el]].

*** Connecting via Vim

    You can connect to Swank from vim with [[http://www.vim.org/scripts/script.php?script_id%3D2531][SLIMV]]. See the SLIMV installation
    instructions for more details.

** Shutting Down Swank

   Immutant will automatically shutdown the Swank service for you when your
   application is undeployed, but if you need to do so before undeploy you
   can do so using the [[./apidoc/immutant.repl.html#var-stop-swank][immutant.repl/stop-swank]] function:

   #+begin_src clojure
      ;; no arg needed since only one Swank server can exist for the application
      (clojure.repl/stop-swank)
   #+end_src


* Reloading application dependencies
  
  Immutant provides tools to aid interactive repl-based development via
  the [[./apidoc/immutant.dev.html][immutant.dev]] namespace. Currently, it provides three functions for 
  reloading, updating, and viewing your application's dependencies in container:

  - [[./apidoc/immutant.dev.html#var-reload-project!][immutant.dev/reload-project!]] Resets the application's class loader
    to provide the paths and dependencies in the from the given
    project. If no project is provided, the =project.clj= for the
    appplication is loaded from disk. If used under clojure > 1.3.0,
    this will also make any new data readers from the dependencies
    available.  Returns the project map.
  - [[./apidoc/immutant.dev.html#var-add-dependencies!][immutant.dev/add-dependencies!]] Adds the given dependencies into
    the currently active project's dependency set and resets the
    application's class loader to provide the paths and dependencies
    from that project (via =reload-project!=). Each dep can either be
    a lein coordinate ('[foo-bar "0.1.0"]) or a path (as a String) to
    be added to =:source-paths=.  Returns the project map.
  - [[./apidoc/immutant.dev.html#var-current-project][immutant.dev/current-project]] Returns the map representing the
    currently active leiningen project. This will be the last project
    reloaded by =reload-project!=, or the map read from =project.clj=
    if =reload-project!= has yet to be called.
    
    Examples:

    #+begin_src clojure
      ;; assuming we have an app loaded that initially only depends on clojure
      ;; (from its project.clj)
      (require '[immutant.dev :as dev]
               '[clojure.java.io :as io])
      
      (:dependencies (dev/current-project)) ; => #{[org.clojure/clojure "1.4.0"]}
      
      ;; let's add more deps
      (dev/add-dependencies! '[dep-1 "1.0.0"] '[dep/two "0.1.0-SNAPSHOT"] "extra")
      
      (:dependencies (dev/current-project)) ; => #{[org.clojure/clojure "1.4.0"] [dep-1 "1.0.0"] [dep/two "0.1.0-SNAPSHOT"]}
      
      (:source-paths (dev/current-project)) ; => [["/path/to/app/root/src", "/path/to/app/root/extra"]]
      
      ;; now let's reset the deps to those specified in project.clj
      (dev/reload-project!)
      
      (:dependencies (dev/current-project)) ; => #{[org.clojure/clojure "1.4.0"]}
      
      ;; let's add a path to :source-paths directly
      (dev/reload-project! ((dev/current-project) [:source-paths]
                            #(conj % "something")))
      
      (:source-paths (dev/current-project)) ; => [["/path/to/app/root/src", "/path/to/app/root/something"]]
      
    #+end_src
  


